import sys
import os
import random
from concurrent.futures import ProcessPoolExecutor

import numpy as np
import pickle

from typing import Tuple, List


def process_complex_matrix(data:str, L:int):
    '''
    L (int): System size

    For use with process_single_simulation()
    Processes a single string containing data for a complex matrix into a numpy 2d array
    '''

    # Strip then split the string by newlines and tabs
    data = data.strip().split()

    # Ensure there are a correct number of data points
    if len(data) != 2*L**2:
        raise ValueError(f"process_complex_matrix(): Size of data incorrect! Total number of values was not as expected 2*L**2 ({2*L**2}) representing a complex LxL matrix, but instead was {len(data)}")
    
    # Convert to a numpy array of floats
    data = np.array(data, dtype=np.float32)
    
    # Split the array into real and imaginary parts, assuming interlacing
    real_parts = data[0::2]
    imag_parts = data[1::2]
    
    # Combine real and imaginary parts into a complex numpy array
    complex_data = real_parts + 1j * imag_parts
    
    # Reshape the array into the matrix form
    return complex_data.reshape((L, L))

def process_real_vector(data:str, L:int):
    '''
    L (int): System size

    For use with process_single_simulation()
    Processes a single string containing data for a real vector into a numpy 1d array
    '''

    # Strip then split the string by newlines and tabs
    data = data.strip().split()

    # Ensure there are a correct number of data points
    if len(data) != L:
        raise ValueError(f"process_real_vector(): Size of data incorrect! Total number of values was not as expected L ({L}) representing a real-valued vector of size L, but instead was {len(data)}")
    
    # Convert to a numpy array of floats
    vector = np.array(data, dtype=np.float32)

    return vector

def process_single_simulation(path:str, L:int)->Tuple[np.array]:

    '''
    path (str): Path to file containing data for a single simulation
    L (int): System size

    Returns: Tuple[np.array]: A 3-tuple containing a 3d complex-valued numpy array representing batched 2d rho matrices (batch, L, L), a 2d real-valued numpy array representing batched 1d Q vectors (batch, L), and another 2d real-valued numpy array representing batched 2d P vectors (batch, L)
    '''

    with open(path, 'r') as f:
        data = f.read()
    
    data.strip()
    data = data.split("######")

    # Because there is delimiter at beginning, first element will be empty string. Remove it
    if len(data[0]) == 0:
        del data[0]

    if not len(data) % 3 == 0:
        raise ValueError(f"process_single_simulation(): Number of data points not divisible by 3! Number was: {len(data)}")

    n_sim_steps = len(data) / 3

    rho_data = data[0::3]
    Q_data = data[1::3]
    P_data = data[2::3]

    # Process all string data into numpy arrays
    rho_matrices = [process_complex_matrix(single_rho_data, L) for single_rho_data in rho_data]
    Q_vectors = [process_real_vector(single_Q_data, L) for single_Q_data in Q_data]
    P_vectors = [process_real_vector(single_P_data, L) for single_P_data in P_data]

    # Stack each into a single np array
    rho_matrices = np.stack(rho_matrices, axis=0)
    Q_vectors = np.stack(Q_vectors, axis=0)
    P_vectors = np.stack(P_vectors, axis=0)


    ## Sanity checks
    if not (len(rho_matrices) == len(Q_vectors) == len(P_vectors)):
        raise ValueError(f"process_simulation_group(): Number of rho matrices, Q vectors, and/or P vectors is not the same! len(rho): {len(rho_matrices)}\tlen(Q): {len(Q_vectors)}\tlen(P): {len(P_vectors)}")
    if len(rho_matrices.shape) != 3:
        raise ValueError(f"process_simulation_group(): rho_matrices is not 3-dimensional! rho_matrices.shape: {rho_matrices.shape}")
    if len(Q_vectors.shape) != 2:
        raise ValueError(f"process_simulation_group(): Q_vectors is not 2-dimensional! Q_vectors.shape: {Q_vectors.shape}")
    if len(P_vectors.shape) != 2:
        raise ValueError(f"process_simulation_group(): P_vectors is not 2-dimensional! P_vectors.shape: {P_vectors.shape}")

    return rho_matrices, Q_vectors, P_vectors


def process_simulation_group(data_dir:str, L:int, n_sims:int, n_workers:int=4):

    '''
    Processes the data generated by multiple simulations ran by datagen.py

    data_dir (str): Path to directories containing simulation data
    L (int): System size
    n_sims (int): Number of simulations to process

    returns: List[tuple[np.array]]: An iterable containing data for n_sims simulations. Each simulation is a tuple of 3 numpy arrays: a 3d complex64 density_mat array, a 2d float32 displacement array, and a 2d float32 momentum array. Each of these 3 arrays has dim 0 as batch dimension and have the same number of batches
    '''
    
    # Paths to all individual simulations
    all_sim_paths = []
    for sim_num in range(n_sims):
        all_sim_paths.append(os.path.join(data_dir, f"data_sim_{sim_num}.dat"))

    # Check that all data exists
    for sim_path in all_sim_paths:
        if not os.path.exists(sim_path):
            raise FileNotFoundError(f"process_simulation_group(): Requires simulations 0 through {n_sims-1} but data_sim_{sim_num}.dat not found!")

    # We will use ProcessPoolExecutor to process simulations
    with ProcessPoolExecutor(max_workers=n_workers) as executor:
        results = list(executor.map(process_single_simulation, all_sim_paths, [L]*n_sims))

    if len(results) != n_sims:
        raise ValueError(f"process_simulation_group(): len(results) != n_sims: {len(results)} != {n_sims}")

    return results


    
def pickle_data(save_path, data):
    '''
    Save path should end in .pkl or something that is allowed. It should NOT exist
    '''
    with open(save_path, 'wb') as file:
        pickle.dump(data, file)
        

def unpickle_data(save_path):
    with open(save_path, 'rb') as file:
        data = pickle.load(file)
    return data